========================================
Сервис оценки качества произношения
========================================


На входе для каждой фразы есть набор образцов с правильным произношением.
Неправильные будем набирать в процессе тестирования



Признаками звукозаписи является последовательность векторов MFCC:
- запись покрывается окнами длиной примерно 0.25 мс с шагом 10 мс
- для каждого окна вычисляется набор признаков MFCC
- также в каждом окне вычисляются 1-я и 2-я производная от вектора MFCC по времени

После этого переходим к обучению программы.





-----------------------------------------------
Вычисление первичных признаков в одном окне
-----------------------------------------------

1) Файл загружается в память и преобразуется в массив чисел + fps
2) Массив чисел нормируется по амплитуде (чтобы максимальная амплитуда равнялась 1)
3) Выполняется поиск начала и конца речи 
   (чтобы длительность молчания в начале и конце записи была у всех одинакова)
4) Убираем шум
4) Промежуток от начала до конца речи делится на окна, 
   Лучше будет, если в каждом окне количество точек с данными будет равно 2^N
   для каждого окна вычисляем вектор признаков MFCC:
   4.1 выполняем быстрое преобразование Фурье
   4.2 умножаем спектр на M разных функций
   4.3 и выполняем обратное косинусное преобразование, получая M чисел - вектор MFCC
   Эту часть лучше оптимизировать по скорости

Элементарные алгоритмы:
- открыть звуковой файл
- получить его свойства и цепочку значений амплитуды.
- выполнить быстрое преобразование Фурье
- выполнить обратное косинусное преобразование
Оптимизировать по скорости



-----------------------------------------------
Подготовка данных для обучения
-----------------------------------------------

Голоса разделяем на женские и мужские. Хотелось бы иметь для начала хотя бы 10 голосов,
где каждый правильно прочитает фразу по 3-4 раза.

Для каждой звукозаписи-образца вычисляем первичные признаки: набор векторов MFCC и время для каждого вектора.

Разделяем запись на "почти фонемы" с помощью DTW


? Вычисляем среднее количество окон по всем образцам
? В каждом образце с помощью интерполяции приводим количество векторов MFCC к этому значению
? И вычисляем 1-ю и 2-ю производные по времени от MFCC.
? Таким образом, все образцы звука получат равное количество признаков.
? В каждом окне вычисляем среднее значение вектора признаков


? 
? 
? 
? 
? 
? 


Элементарные алгоритмы:
- DTW
- интерполяция векторов
- вычисление производных


-----------------------------------------------
Оценка произношения
-----------------------------------------------

1) сервлет принимает из сети отправленный файл и сохраняет его в какую-то директорию,
   файл потом будет использован для обучения программы.
   Сервлет должен проверить права доступа (например, некий токен с ограниченным временем жизни)
2) вычисляем первичные признаки файла
3) методом DTW совмещаем первичные признаки с главным образцом.
4) интерполяцией извлекаем _правильное_ количество признаков.
5) передаём признаки в Классификатор





-----------------------------------------------
Классификатор, Версия 1
-----------------------------------------------

На вход получаем две последовательности признаков MFCC





DTW формирует "траекторию" на матрице расстояний.
У идеальной траектории формула s=t, у неидеальной s=f(t)
[ t=1,2,3,  T (кол-во окон в образце звука) ]
отклонение можно сосчитать как d(t) = f(t) - t.

Кроме того, вдоль траектории есть расстояния между фреймами.
Считаем расстояние между окнами f(t) независимым от траектории,
получаем 2-мерное распределение
P(d,f,t) = P(d,t) * P(f,t)

По обучающей выборке сосчитываем среднеквадратичные отклонения для d(t) и f(t)
( среднее значение <d(t)> = 0 <f(t)> = 0 )
И потом для каждого t вычисляем уровень значимости по распределению Стьюдента
и всё 
- суммируем по t 
- или подсчитываем, сколько точек траектории выходят за пределы допустимого.

На выходе получаем меру схожести.

Элементарные алгоритмы:
- DTW
- интерполяция векторов
- вычисление производных


-----------------------------------------------
Классификатор, Версия 2
-----------------------------------------------

Скрытая марковская модель

После интерполяции вычисляем 1-ю и 2-ю производные от MFCC.
========================================
Сервис оценки качества произношения
========================================


На входе для каждой фразы есть набор образцов с правильным произношением.
Неправильные будем набирать в процессе тестирования



Признаками звукозаписи является последовательность векторов MFCC:
- запись покрывается окнами длиной примерно 0.25 мс с шагом 10 мс
- для каждого окна вычисляется набор признаков MFCC
- также в каждом окне вычисляются 1-я и 2-я производная от вектора MFCC по времени

После этого переходим к обучению программы.





-----------------------------------------------
Вычисление первичных признаков в одном окне
-----------------------------------------------

1) Файл загружается в память и преобразуется в массив чисел + FPS
   Надо привести FPS к стандартному значению, например 22kHz или 11kHz

2) Массив чисел нормируется по амплитуде (чтобы максимальная амплитуда равнялась 1)
   (Надо попробовать)

3) Выполняется поиск начала и конца речи 
   (чтобы длительность молчания в начале и конце записи была у всех одинакова)
   Выполняем поиск пауз, слишком длинные сокращаем, короткие паузы не изменяем
   См поиск_тишины

4) Убираем шум (пока непонятно, как именно)

5) Промежуток от начала до конца речи делится на окна, 
   Лучше будет, если в каждом окне количество точек с данными будет равно 2^N
   (Испытать N=128, 256, 512, 1024)
   для каждого окна вычисляем вектор признаков MFCC из 16 чисел
   (меньше 13 никто не берёт, больше 32 тоже, надо будет подобрать количество в экспериментах)
   См Вычисление_MFCC

6) Каждому окну кроме MFCC приписываем уровень_энергии


На выходе получаем массив признаков:
    Для каждого окна:
        вектор MFCC
        значение энергии

-----------------------------------------------
Вычисление_энергии
-----------------------------------------------
Свёртка амплитуды с собой = выборочная оценка дисперсии значений амплитуды в окне
Среднее значение амплитуды считаем нулевым.

-----------------------------------------------
Вычисление_MFCC (окно, fps)
-----------------------------------------------
   4.1 выполняем быстрое преобразование Фурье
   4.2 умножаем спектр на M разных функций
   4.3 и выполняем обратное косинусное преобразование, получая M чисел - вектор MFCC
   Эту часть лучше оптимизировать по скорости


-----------------------------------------------
поиск_тишины
-----------------------------------------------
Составляем гистограмму : количество окон + значение энергии

Приближаем гистограмму суммой 2-х нормальных распределений,
Находим минимум суммы - это будет пороговое значение энергии между речью и тишиной.

Или интерполяция по гистограмме
Или сглаживание по гистограмме



-----------------------------------------------
Разделение_на_фонемы
-----------------------------------------------
Способ 1
1) составляем матрицу расстояний: 
   в точке (x,y) вписываем расстояние между признаками окна x и окна y
   вычисления должны быть ленивыми (т.е. число не вычисляется, пока не понадобится)
2) пройти над диагональю
   и найти локальные максимумы сглаженной функции расстояния
3) пройти по 2-й наддиагонали
   и найти локальные максимумы сглаженной функции расстояния
   ...
4) пройти по N-й наддиагонали
   и найти локальные максимумы сглаженной функции расстояния
5) отметить локальные максимумы, которые встретились во всех 
   N множествах и считать эти максимумы границами фонем.


Способ 2
Вычислять сумму расстояний S(n) 
в квадрате  x=x1..x1+n && y=y1..y1+n
и смотреть, когда sqrt(S(n)) - sqrt(S(n-1)) значительно изменится
т.е. найти максимум функции 
d2S(n) = sqrt(S(n-1)) - 2*sqrt(S(n)) +sqrt(S(n+1))

"Значительно" подразумевает некое пороговое значение.

После разделения на фонемы мы получаем последовательность чисел -
номера окон, которые считаются границами фонем.



-----------------------------------------------
Выбор_начала_отсчёта
-----------------------------------------------

Выбираем типичного представителя из набора звукозаписей

Для каждой пары записей из обучающего набора

(1) Вычисляем, насколько сильно надо преобразовать время.
    t2 = f(t1)  df/dt >=0 
    Это площадь между диагональю (идеальное решение) и реальным отображением.
    Чтобы соблюсти масштаб, разделим на площадь прямоугольника

(2) Вычисляем, сумму расстояний после преобразования времени
    Чтобы соблюсти масштаб, разделим сумму расстояний на длину линии.

(3) Вычисляем количество окон в образце.

Расширение: разделить на фонемы и для каждой фонемы отдельно
вычислить (1) и (2)

Потом вычисляем по каждому измерению среднее значение <x[i]> и дисперсию D2[i]
Выбираем образец, у которого минимально значение величины
			Summa[ (x[i] - <x[i]>)^2 / D2[i], i=1, M ]
где i - номер признака











-----------------------------------------------
Подготовка данных для обучения
-----------------------------------------------

Голоса разделяем на женские и мужские. Хотелось бы иметь для начала хотя бы 10 голосов,
где каждый правильно прочитает фразу по 3-4 раза.

Для каждой звукозаписи-образца вычисляем первичные признаки: набор векторов MFCC и время для каждого вектора.

Разделяем запись на "почти фонемы" с помощью матрицы расстояний и интегральных сумм


? Вычисляем среднее количество окон по всем образцам
? В каждом образце с помощью интерполяции приводим количество векторов MFCC к этому значению
? И вычисляем 1-ю и 2-ю производные по времени от MFCC.
? Таким образом, все образцы звука получат равное количество признаков.
? В каждом окне вычисляем среднее значение вектора признаков


? 
? 
? 
? 
? 
? 


Элементарные алгоритмы:
- DTW
- интерполяция векторов
- вычисление производных


-----------------------------------------------
Оценка произношения
-----------------------------------------------

1) сервлет принимает из сети отправленный файл и сохраняет его в какую-то директорию,
   файл потом будет использован для обучения программы.
   Сервлет должен проверить права доступа (например, некий токен с ограниченным временем жизни)
2) вычисляем первичные признаки файла
3) методом DTW совмещаем первичные признаки с главным образцом.
4) интерполяцией извлекаем _правильное_ количество признаков.
5) передаём признаки в Классификатор





-----------------------------------------------
Классификатор, Версия 1
-----------------------------------------------

На вход получаем две последовательности признаков MFCC





DTW формирует "траекторию" на матрице расстояний.
У идеальной траектории формула s=t, у неидеальной s=f(t)
[ t=1,2,3,  T (кол-во окон в образце звука) ]
отклонение можно сосчитать как d(t) = f(t) - t.

Кроме того, вдоль траектории есть расстояния между фреймами.
Считаем расстояние между окнами f(t) независимым от траектории,
получаем 2-мерное распределение
P(d,f,t) = P(d,t) * P(f,t)

По обучающей выборке сосчитываем среднеквадратичные отклонения для d(t) и f(t)
( среднее значение <d(t)> = 0 <f(t)> = 0 )
И потом для каждого t вычисляем уровень значимости по распределению Стьюдента
и всё 
- суммируем по t 
- или подсчитываем, сколько точек траектории выходят за пределы допустимого.

На выходе получаем меру схожести.

Элементарные алгоритмы:
- DTW
- интерполяция векторов
- вычисление производных


-----------------------------------------------
Классификатор, Версия 2
-----------------------------------------------

Скрытая марковская модель

После интерполяции вычисляем 1-ю и 2-ю производные от MFCC.



